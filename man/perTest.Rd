% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pemutation_testing.R
\name{perTest}
\alias{perTest}
\alias{perTest.default}
\alias{perTest.matrix}
\alias{perTest.data.frame}
\title{Permutation testing for differences in frequency of a binary event.}
\usage{
perTest(x, ...)

\method{perTest}{default}(
  x,
  f,
  background,
  alternative = c("both", "greater", "less"),
  n_iter = 1000,
  laplace = 1,
  ci_type = c("bca", "percentile"),
  ci_level = 0.95,
  as_data_frame = FALSE,
  ...
)

\method{perTest}{matrix}(
  x,
  f,
  background = NULL,
  alternative = c("both", "greater", "less"),
  n_iter = 1000,
  laplace = 1,
  ci_type = c("bca", "percentile"),
  ci_level = 0.95,
  as_data_frame = FALSE,
  compress = FALSE,
  adj_method = "none",
  .parallel = TRUE,
  .n_chunks = NULL,
  .paropts = furrr_options(seed = TRUE),
  ...
)

\method{perTest}{data.frame}(
  x,
  f,
  background = NULL,
  alternative = c("both", "greater", "less"),
  n_iter = 1000,
  laplace = 1,
  ci_type = c("bca", "percentile"),
  ci_level = 0.95,
  as_data_frame = FALSE,
  compress = FALSE,
  adj_method = "none",
  .parallel = TRUE,
  .n_chunks = NULL,
  .paropts = furrr_options(seed = TRUE),
  ...
)
}
\arguments{
\item{x}{a binary numeric vector, a two-level factor, a binary numeric
matrix, or a data frame of numeric vectors or two-level factors. If a matrix
or a data frame is provided, the columns will define the variables and
observations are represented by rows.}

\item{...}{additional arguments passed to the methods.}

\item{f}{a factor that defines the analysis groups}

\item{background}{a numeric vector of length equal to \code{f}'s length, a binary
numeric matrix, a data frame of numeric vectors or two-level factors.
See Details.}

\item{alternative}{a string that specifies if the test should check for
enrichment ('greater'), depletion ('less') or both ('both', the default
option).}

\item{n_iter}{number of algorithm iterations.}

\item{laplace}{Laplace smoother used for calculation of the enrichment score.}

\item{ci_type}{type of the confidence intervals: bias-corrected and
accelerated ('bca', the default option), or percentile confidence intervals
('percentile').}

\item{ci_level}{alpha level for calculation of the confidence intervals of
the enrichment scores.}

\item{as_data_frame}{logical, should the output of the function be coerced
to a data frame or a list of data frames? If \code{TRUE}, this may make the
function  slower and memory-consuming.}

\item{compress}{logical, should the output list be compressed to a single
data frame? If \code{TRUE}, this may make the function  slower and
memory-consuming. Ignored if \code{as_data_frame = FALSE}.}

\item{adj_method}{method of p value adjustment as defined by
\code{\link[stats]{p.adjust}}. By default no multiple testing adjustment is
applied to the result.
Ignored if \code{compress = FALSE} or \code{as_data_frame = FALSE}.}

\item{.parallel}{logical, should the function be run in parallel? This option
works only if a suitable parallel backend is declared via
\code{\link[future]{plan}}.}

\item{.n_chunks}{number of chunks for the parallel run. If not provided,
the number will be inferred from the number of available cores.}

\item{.paropts}{options for the parallel run provided as a
\code{\link[furrr]{furrr_options}} object.}
}
\value{
a data frame or a matrix, or a named list of data frames or matrices
with the following columns:
\itemize{
\item \strong{variable}: names of the variables
\item \strong{strata}: the analysis group, named after levels of factor \code{f}, that
defines the analysis groups
\item \strong{ES}: enrichment score
\item \strong{lower_ci} and \strong{upper_ci}: lower and upper confidence interval of
the enrichment score
\item \strong{p_value}: p value for enrichment or depletion in the analysis groups
\item \strong{n_observed}: observed numbers of events in the analysis groups
\item \strong{n_expected}: expected numbers of events in the analysis groups averaged
by all iterations
\item \strong{n_total}: total numbers of complete observations in the analysis groups
\item \strong{chisq}: value of \eqn{\chi^2} statistic for global differences between
the observed and expected event rates
\item \strong{df}: degrees of freedom of the \eqn{\chi^2} statistic. Essentially
the number of analysis group minus one
\item \strong{cramer_v}: effect size of the global difference in event rates
\item \strong{global_p_value}: p value of the global difference in event rates
}

If \code{as_data_frame = FALSE}, a matrix or a list of matrices is returned, with
strata names in row names, as well as p and global p values corrected for
multiple testing.
}
\description{
Permutation testing for an enrichment or depletion of a binary event
(e.g. presence of a somatic mutation) in analysis groups.
}
\details{
\strong{General principle}

By principle, the permutation test compares the observed rate of a binary
event in an analysis group with N random permutations of the event vector
weighted by overall event rate in the observations.
In an illustrative example, the test may be used to assess enrichment or
depletion of a given somatic mutation in analysis group as compared with
random permutations which are weighted by the general mutation rates in
biological samples. In this particular context, the enrichment estimates
(Enrichment Scores, which resemble odds ratios) and p values returned
by the test are expected to be more reliable as compared with classical
enrichment assessment methods such as Fisher's exact test or logistic
regression, which assume that the mutation rates are independently and
identically distributed in the analysis groups.

\strong{Enrichment or depletion of events in an analysis group}

The \eqn{H_0} hypothesis of the test is that the event frequency in an
analysis group is attributed solely to the random variability and differences
in overall event rate between single samples.

Lets code the vector of 0/1-coded events for \eqn{n} observations as
\eqn{X = [x_1, x_2, ..., x_n]}.
The observations are assigned to \eqn{p} analysis groups defined by the
vector \eqn{F = [f_1, f_2, ..., f_n]}.
For the observations, weights \eqn{WT = [wt_1, wt_2, ..., wt_n]} are computed,
where each weight corresponds to the column mean of the background matrix,
i.e. the overall probability of the event.
Next, \eqn{N_{iter}} permutations \eqn{P = [p_1, p_2, ..., p_n]} of \eqn{X},
i.e. random reshuffles, are drawn where the event probabilities for the
observations are weighted by \eqn{WT} vector.
Those permutations are used to estimate the expected frequency of the event
in each of the analysis group.

To test for enrichment in an analysis group, we compare the observed sum of
events in the \eqn{f^{th}} group:

\deqn{O_f = \sum X_f}

with the expected sum of events in the \eqn{f^{th}} group for iterations
\eqn{i, ..., N_{iter}}:

\deqn{E_{f, i} = \sum P_{f, i}}

If \eqn{O_f > E_{f, i}} in a particular iteration, this provides a case
for \eqn{H_0} rejection, which we code \eqn{H_{f, i} = 1}. Otherwise, we
code \eqn{H_{f, i} = 0}. The p-value for significant enrichment in the
\eqn{f^{th}} group is simply computed by summing the \eqn{H_0} rejection
cases over iterations and dividing it by the total iteration number:

\deqn{p_f = \frac{(\sum_{i}^{N_{iter}} H_{f, i}) + 1}{N_{iter}}}

The enrichment score in the \eqn{f^{th}} group is calculated as a ratio of
the observed and expected counts of events averaged over the iterations:

\deqn{ES_f = \frac{\sum_{i}^{N_{iter}} \frac{O_f + l}{E_{f, i} + l}}{N_[iter]}}

Note that in the formula above, the expected and observed counts are
corrected by addition of a constant \eqn{l} Laplace smoother, which is there
to prevent division by 0 and expansion of \eqn{ES_f} for small values of
\eqn{E_{f, i}}. Confidence intervals of \eqn{ES_f} are derived either
from percentiles or computed with a more robust
\href{https://blogs.sas.com/content/iml/2017/07/12/bootstrap-bca-interval.html}{BCA algorithm}.

\strong{Global difference between the observed and expected event rates}

To assess the global difference between the observed rate of the event and
the expected event rate attributable solely to varying overall event rates in
the observations, a modified Pearson's \eqn{\chi^2} test is used.
The Yates-corrected test statistic \eqn{\chi^2} is computed as follows:

\deqn{\chi^2 = \sum_{f = 1}^{k} \frac{(\mid O_f - E_f \mid - 0.5)^2}{E_f}}

for \eqn{f = 1, ..., k} analysis groups, \eqn{O_f} observed frequency of the
event in the f^th^ group, and \eqn{E_f} expected frequency of the event in
the f^th^ group obtained by weighted permutation.
Effect size of the global difference is measured by Cramer's V:

\deqn{V = \sqrt{\frac{\chi^2/N}{min(k - 1, r - 1)}}},

where \eqn{N} denotes the total number of observation, \eqn{k} stands for
the analysis group number, and \eqn{r} is the minimum size of the analysis
groups.

\strong{Background object}

This object provided as \code{background} argument stores event rates for all
measured variables (e.g. all somatic mutations returned in an sequencing
experiment) and will be used to estimate observation-specific weights
applied to the algorithm permutations.
It may be provided in three forms:
\itemize{
\item as a numeric vector, whose length corresponds to the number of observations.
This option may be used when the user intends to used pre-computed
observation weights such as total mutation burden
\item as a binary numeric matrix, i.e. matrix that contains 0 and 1 values only.
Features are represented by the columns, observations are represented by
the rows
\item as a binary data frame or a data frame that stores two level factors.
Analogically, features are represented by the columns and observations are
coded by the rows
}

If no background is
provided, the X matrix or a data frame will be used instead; for just few
variables of interest, this is certainly not an optimal solution
}
